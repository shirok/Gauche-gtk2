;;
;;  Copyright(C) 2002-2004 by Shiro Kawai (shiro@acm.org)
;;
;;  Permission to use, copy, modify, distribute this software and
;;  accompanying documentation for any purpose is hereby granted,
;;  provided that existing copyright notices are retained in all
;;  copies and that this notice is included verbatim in all
;;  distributions.
;;  This software is provided as is, without express or implied
;;  warranty.  In no circumstances the author(s) shall be liable
;;  for any damages arising out of the use of this software.
;;
;; $Id: gtk-lib.hints,v 1.60 2007/08/22 17:06:42 maruska Exp $
;;
;; Auxiliary stuff for autogenerated stub files.
;; If you edit this file, you have to regenerate stub files by h2stub.scm

;; mmc:  i never get this type --- fixme: i do return it (only) to scheme!
(define-type <g-list> "GList*" "Glib (single linked) list" ;;  owned by the application ?
  "SCM_PAIRP"  ;; fixme !!! check better ?
  "Scm_ListToGList"
  "Scm_GList_to_list")


(define-type <const-g-list> "GList*" "Glib (single linked) list" ;;  owned by the application!!!  don't free
  "SCM_PAIRP"  ;; fixme !!! check better ?
  "Scm_ListToGList"
  "Scm_const_GList_to_list")


; <g-value>
;; has to be freed after usage!!!
; Scm_UnboxGValue
(define-type <g-value> "GValue*" "General (arbitrary type) value "
  "SCM_PAIRP"
  "Scm_UnboxGValue"
  "Scm_obj_to_gvalue"
  )


;; clone a type?    fixme: Still necessary?
(define-type <gunichar> "gunichar" "A type which can hold any UCS-4 character code"
  "SCM_CHARP" "Scm_char2gunichar" "Scm_gunichar2char")



;; mmc: in 2.10.6  there is #ifdef .... inside the Enum, and it is not parsed correctly.
(input-file "gtkobject.h")

(let1 en (find-enum "GtkObjectFlags")
  (if (member "defined" (ref en 'values) string=?)
      (slot-set! en 'values
        (delete! "defined" (ref en 'values)))
    (begin
      (logformat "no defined: ~s\n~s\n"
        (ref en 'values)
        (member "defined" (ref en 'values) string=?))
                                        ;(error "not found!")
      )))

;;==================================================================
;; gtkaccelgroup.h
;;

(input-file "gtkaccelgroup.h")

;; gtk_accel_group_connect

(define-cproc-fix gtk-accel-group-connect
  (fix-arguments! '(accel_group::<gtk-accel-group>
                    accel_key::<uint>
                    accel_mods::<int>
                    accel_flags::<int>
                    handler::<procedure>))
  (fix-body!
   "gtk_accel_group_connect(accel_group, accel_key, accel_mods, accel_flags,
                            Scm_MakeGClosure(handler));
    SCM_RETURN(SCM_UNDEFINED);"))

;; gtk_accel_group_connect_by_path
(define-cproc-fix gtk-accel-group-connect-by-path
  (fix-arguments! '(accel_group::<gtk-accel-group>
                    accel_path::<const-gchar*>
                    closure::<procedure>))
  (fix-body!
   "gtk_accel_group_connect_by_path(accel_group, accel_path,
                                    Scm_MakeGClosure(closure));
    SCM_RETURN(SCM_UNDEFINED);"))

;; gtk_accel_group_disconnect
(define-cproc-fix gtk-accel-group-disconnect
  (fix-arguments! '(accel_group::<gtk-accel-group>
                    accel_key::<uint>
                    accel_mods::<int>
                    accel_flags::<int>
                    handler::<procedure>))
  (fix-body!
   "gtk_accel_group_connect(accel_group, accel_key, accel_mods, accel_flags,
                            Scm_MakeGClosure(handler));
    SCM_RETURN(SCM_UNDEFINED);"))

(define-cproc-fix gtk-accel-groups-from-object
  (fix-body! "GSList *lis = gtk_accel_groups_from_object(object);
  ScmObj r = Scm_GoSListToList(lis);
  /* Should I free lis?  Gtk manual is not clear about that. */
  SCM_RETURN(r);"))

(raw-code
 "static gboolean accel_group_finder(GtkAccelKey *key, GClosure *clo,
                                     gpointer data)
 {
   ScmObj r = Scm_ApplyRec1(SCM_OBJ(data), SCM_MAKE_GTK_ACCEL_KEY(key));
   return (!SCM_FALSEP(r));
 }")

(define-cproc-fix gtk-accel-group-find
  (fix-arguments! '(accel_group::<gtk-accel-group>
                    find-func::<procedure>))
  (fix-body! "GtkAccelKey *key;
  key = gtk_accel_group_find(accel_group, accel_group_finder, (gpointer)find_func);
  if (key) {
    SCM_RETURN(SCM_MAKE_GTK_ACCEL_KEY(key));
  } else {
    SCM_RETURN(SCM_FALSE);
  }"))

(define-cproc-fix gtk-accelerator-parse
  (fix-arguments! '(accelerator::<const-gchar*>))
  (fix-body! "guint key; GdkModifierType mods;
  gtk_accelerator_parse(accelerator, &key, &mods);
  SCM_RETURN2(Scm_MakeInteger(key), Scm_MakeIntegerU(mods));"))

(define-cproc-fix gtk-accel-group-query
  (fix-arguments! '(accel_group::<gtk-accel-group>
                    accel_key::<uint>
                    accel_mods::<int>))
  (fix-body! "guint n_entries;
  GtkAccelGroupEntry *ent = gtk_accel_group_query(accel_group, accel_key, accel_mods, &n_entries);
  if (ent == NULL) {
    SCM_RETURN(SCM_NIL);
  } else {
    ScmObj h = SCM_NIL, t = SCM_NIL; int i;
    for (i=0; i<n_entries; i++) {
      SCM_APPEND1(h, t, SCM_MAKE_GTK_ACCEL_GROUP_ENTRY(&ent[i]));
    }
    SCM_RETURN(h);
  }"))
                  

;;==================================================================
;; gtkaccellabel.h
;;

(input-file "gtkaccellabel.h")

;; GtkAccelLabel - queue-id is deprecated in GTk-2.2
(define-cclass-fix <gtk-accel-label>
  (ignore-field! 'queue-id))

(define-cproc-fix gtk-accel-label-set-accel-closure
  (fix-arguments! '(accel-label::<gtk-accel-label> accel-closure::<procedure>))
  (fix-body! "gtk_accel_label_set_accel_closure(accel_label, Scm_MakeGClosure(accel_closure)); SCM_RETURN(SCM_UNDEFINED);"))

;;==================================================================
;; gtkbindings.h
;;

(input-file "gtkbindings.h")

;; GtkBindingArg - it's a union.  For now, I disable direct access
;; to the fields.  A generic get-value type op will be required.

(define-cclass-fix <gtk-binding-arg>
  (set! (fields-of self) '()))

(define-cproc-fix gtk-binding-set-by-class
  (fix-arguments! '(type::<class>))
  (fix-body!
   "GType gtype = Scm_ClassToGtkType(type); gpointer gclass;
  GtkBindingSet *bset;
  if (gtype == G_TYPE_INVALID) {
    Scm_Error(\"given class doesn't correspond to an GObject class: %S\", type);
  }
  gclass = g_type_class_ref(gtype);
  bset = gtk_binding_set_by_class(gclass);
  g_type_class_unref(gclass);
  SCM_RETURN(Scm_MakeGtkBindingSet(bset));"
   ))

;;==================================================================
;; gtkbox.h
;;

(input-file "gtkbox.h")

(define-cproc-fix gtk-box-query-child-packing
  (fix-arguments! '(box::<gtk-box>
                    child::<gtk-widget>))
  (fix-body! "gboolean expand, fill; guint padding; GtkPackType type;
  gtk_box_query_child_packing(box, child, &expand, &fill, &padding, &type);
  SCM_RETURN4(SCM_MAKE_BOOL(expand), SCM_MAKE_BOOL(fill),
              Scm_MakeIntegerU(padding), Scm_MakeInteger(type));"))

;;==================================================================
;; gtkcalendar.h
;;

(input-file "gtkcalendar.h")

(define-cproc-fix gtk-calendar-get-date
  (fix-arguments! '(calendar::<gtk-calendar>))
  (fix-body!
   "guint year, month, day;
  gtk_calendar_get_date(calendar, &year, &month, &day);
  SCM_RETURN3(SCM_MAKE_INT(year), SCM_MAKE_INT(month), SCM_MAKE_INT(day));"))

;;==================================================================
;; gtkcelleditable.h
;;

(input-file "gtkcelleditable.h")

(disable-cclass <gtk-cell-editable-iface>)

(define-opaque GtkCellEditable :gobject)
(define-type <gtk-cell-editable> "GtkCellEditable*" #f
  "SCM_GTK_CELL_EDITABLE_P" "SCM_GTK_CELL_EDITABLE" "SCM_MAKE_GTK_CELL_EDITABLE")

;;==================================================================
;; gtkclipboard.h
;;

(input-file "gtkclipboard.h")

(define-opaque GtkClipboard :indirect)
(define-type <gtk-clipboard> "GtkClipboard*" #f
  "SCM_GTK_CLIPBOARD_P" "SCM_GTK_CLIPBOARD" "SCM_MAKE_GTK_CLIPBOARD")

;;==================================================================
;; gtkclist.h
;;

(input-file "gtkclist.h")

;; GtkCell is an union.   Disable direct access to the varying fields.
(define-cclass-fix <gtk-cell>
  (ignore-field! 'text)
  (ignore-field! 'pixmap)
  (ignore-field! 'mask)
  (ignore-field! 'spacing)
  (ignore-field! 'widget))





;;==================================================================
;; gtkcolorsel.h
;;

(input-file "gtkcolorsel.h")

(define-cproc-fix gtk-color-selection-get-current-color
  (fix-arguments! '(colorsel::<gtk-color-selection>))
  (fix-body!
   "GdkColor color;
gtk_color_selection_get_current_color(colorsel, &color);
SCM_RETURN(SCM_MAKE_GDK_COLOR(&color));"))



;;==================================================================
;; gtkcombo.h
;;

(input-file "gtkcombo.h")

(define-cproc-fix gtk-combo-set-popdown-strings
  (fix-arguments! '(combo::<gtk-combo> strings::<list>))
  (fix-body!
        "GList *items = NULL; ScmObj sp;
  SCM_FOR_EACH(sp, strings) {
    if (!SCM_STRINGP(SCM_CAR(sp))) 
      Scm_Error(\"string required, but got %S\", SCM_CAR(sp));
    items = g_list_append(items, Scm_GetStringConst(SCM_STRING(SCM_CAR(sp))));
  }
  gtk_combo_set_popdown_strings(combo, items);
  /* items owned by comb box, no need to free */
  SCM_RETURN(SCM_UNDEFINED);"))

;;==================================================================
;; gtkcombox.h
;;

(input-file "gtkcombox.h")

(define-cproc-fix gtk-combo-box-get-active-text
  ;; Returns :   a newly allocated string containing the currently active text. or NULL
  ;(set! (return-type-of self) <const-gchar*>-or-null)
  (fix-body!
   "gchar* result = gtk_combo_box_get_active_text(combo_box);
if (result)
  SCM_RETURN(Scm_GtkGcharPtrBox(result));
else
SCM_RETURN(SCM_FALSE);"
   ))


;;==================================================================
;; gtkcontainer.h
;;

(input-file "gtkcontainer.h")

;; mmc: my new:
;; fixme: how to return <g-list> ??
(disable-cproc gtk-container-get-children)
(define-cproc gtk-container-get-children (container::<gtk-container>)
  ;(fix-body!
  (call <g-list> "gtk_container_get_children"))

;; gtk_container_class_find_child_property
(define-cproc-fix gtk-container-child-get-property
  (fix-arguments! '(container::<gtk-container>
                    child::<gtk-widget>
                    property_name::<const-gchar*>))
;;  gtk_container_class_find_child_property
  (fix-body!
   "
/* printf(\"getting property: %s\\n\", property_name); */

/* Tim:
gchar  *str;   guint  num;  gboolean  someflag;      gtk_container_child_get (child, \"string-prop\", &str, \"num-prop\", &num,
           \"bool-prop\", &someflag, NULL);
*/


/*  What type of GValue we want?  just take the canonical (no conversion needed): */

GType gtype = Scm_ClassToGtkType(SCM_CLASS_OF(container_scm));
if (gtype == G_TYPE_INVALID) {
    Scm_Error(\"bad argument 1: should be a GObject class, a container\");
  }
/*fixme: i should test if it's a container*/
gpointer gclass  = g_type_class_ref(gtype);

GParamSpec* spec;
spec = gtk_container_class_find_child_property (gclass,property_name); 

g_type_class_unref(gclass);

/* GType value_type */
GValue gv = { 0, }; 
/* bzero (&gv, 0, sizeof(GValue)); */

/* g_value_reset(&gv); */
g_value_init(&gv, spec->value_type);

   gtk_container_child_get_property(container, child, property_name, &gv);

SCM_RETURN(Scm_UnboxGValue(&gv));")
  )


;;mmc: do i have tu unref ??
;gtk_container_child_set_property

;; ??? gtk_container_child_type
;gtk_container_class_list_child_properties

; (define-cclass <gparamspec> "GParamSpec*" ...)

;; list of gparamspec* -> slist

(define-cproc gtk-container-class-list-child-properties (type::<class>)
  "GType gtype = Scm_ClassToGtkType(type); gpointer gclass;
if (gtype == G_TYPE_INVALID) {
    Scm_Error(\"given class doesn't correspond to an GObject class: %S\", type);
  }
gclass = g_type_class_ref(gtype);


GParamSpec** specs;
guint n_properties;
specs= gtk_container_class_list_child_properties(gclass, &n_properties);

g_type_class_unref(gclass);

/* make a list of strings.*/
int i;
    ScmObj h = SCM_NIL, t = SCM_NIL;
for(i= 0; i< n_properties; i++){
        SCM_APPEND1(h, t, SCM_MAKE_STR_COPYING(specs[i]->name));  /* mmc: i think i could use  */
    };
g_free(specs);
SCM_RETURN(Scm_Values2(Scm_MakeInteger(n_properties), h));"
   )



;; VA_ :
;; gtk_container_child_get
;; gtk_container_child_set

;;==================================================================
;; gtkdialog.h
;;

(input-file "gtkdialog.h")

;; No va_list API in GtkDialog; we use kludge 
(define-cproc-fix gtk-dialog-new-with-buttons
  (fix-arguments! '(title::<const-gchar*>
                    parent::<gtk-window>-or-null
                    flags::<int> &rest buttons))
  (fix-body!
   "
#define MAX_VARARG 7
  const gchar *lb[MAX_VARARG];
  int id[MAX_VARARG];
  ScmObj bp;
  int nbuttons = 0;
  SCM_FOR_EACH(bp, buttons) {
    if (nbuttons >= MAX_VARARG) Scm_Error(\"too many args for gtk-dialog-new-with-buttons (supported only up to %d)\", MAX_VARARG);
    if (!SCM_STRINGP(SCM_CAR(bp))) Scm_Error(\"string required, but got %S\", SCM_CAR(bp));
    if (!SCM_PAIRP(SCM_CDR(bp))) Scm_Error(\"button list is not even\");
    if (!SCM_INTP(SCM_CADR(bp))) Scm_Error(\"button name %S must followed by an integer response, but got %S\", SCM_CAR(bp), SCM_CADR(bp));
    lb[nbuttons] = (const gchar*)Scm_GetStringConst(SCM_STRING(SCM_CAR(bp)));
    id[nbuttons] = SCM_INT_VALUE(SCM_CADR(bp));
    nbuttons++;
    bp = SCM_CDR(bp);
  }
  switch (nbuttons) {
    case 0: SCM_RETURN(SCM_MAKE_GTK_DIALOG(gtk_dialog_new_with_buttons(title, parent, flags, NULL)));
    case 1: SCM_RETURN(SCM_MAKE_GTK_DIALOG(gtk_dialog_new_with_buttons(title, parent, flags, lb[0], id[0], NULL)));
    case 2: SCM_RETURN(SCM_MAKE_GTK_DIALOG(gtk_dialog_new_with_buttons(title, parent, flags, lb[0], id[0], lb[1], id[1], NULL)));
    case 3: SCM_RETURN(SCM_MAKE_GTK_DIALOG(gtk_dialog_new_with_buttons(title, parent, flags, lb[0], id[0], lb[1], id[1], lb[2], id[2], NULL)));
    case 4: SCM_RETURN(SCM_MAKE_GTK_DIALOG(gtk_dialog_new_with_buttons(title, parent, flags, lb[0], id[0], lb[1], id[1], lb[2], id[2], lb[3], id[3], NULL)));
    case 5: SCM_RETURN(SCM_MAKE_GTK_DIALOG(gtk_dialog_new_with_buttons(title, parent, flags, lb[0], id[0], lb[1], id[1], lb[2], id[2], lb[3], id[3], lb[4], id[4], NULL)));
    case 6: SCM_RETURN(SCM_MAKE_GTK_DIALOG(gtk_dialog_new_with_buttons(title, parent, flags, lb[0], id[0], lb[1], id[1], lb[2], id[2], lb[3], id[3], lb[4], id[4], lb[5], id[5], NULL)));
    case 7: SCM_RETURN(SCM_MAKE_GTK_DIALOG(gtk_dialog_new_with_buttons(title, parent, flags, lb[0], id[0], lb[1], id[1], lb[2], id[2], lb[3], id[3], lb[4], id[4], lb[5], id[5], lb[6], id[6], NULL)));
    default: SCM_RETURN(SCM_UNDEFINED); /*dummy*/
  }
#undef MAX_VARARG
  ")
  )

(define-cproc-fix gtk-dialog-add-buttons
  (set! (return-type-of self) #f)
  (fix-arguments! '(dialog::<gtk-dialog> &rest buttons))
  (fix-body!
   "
#define MAX_VARARG 7
  const gchar *lb[MAX_VARARG];
  int id[MAX_VARARG];
  ScmObj bp;
  int nbuttons = 0;
  SCM_FOR_EACH(bp, buttons) {
    if (nbuttons >= MAX_VARARG) Scm_Error(\"too many args for gtk-dialog-new-with-buttons (supported only up to %d)\", MAX_VARARG);
    if (!SCM_STRINGP(SCM_CAR(bp))) Scm_Error(\"string required, but got %S\", SCM_CAR(bp));
    if (!SCM_PAIRP(SCM_CDR(bp))) Scm_Error(\"button list is not even\");
    if (!SCM_INTP(SCM_CADR(bp))) Scm_Error(\"button name %S must followed by an integer response, but got %S\", SCM_CAR(bp), SCM_CADR(bp));
    lb[nbuttons] = (const gchar*)Scm_GetStringConst(SCM_STRING(SCM_CAR(bp)));
    id[nbuttons] = SCM_INT_VALUE(SCM_CADR(bp));
    nbuttons++;
    bp = SCM_CDR(bp);
  }
  switch (nbuttons) {
    case 0: gtk_dialog_add_buttons(dialog, NULL);
            break;
    case 1: gtk_dialog_add_buttons(dialog, lb[0], id[0], NULL);
            break;
    case 2: gtk_dialog_add_buttons(dialog, lb[0], id[0], lb[1], id[1], NULL);
            break;
    case 3: gtk_dialog_add_buttons(dialog, lb[0], id[0], lb[1], id[1], lb[2], id[2], NULL);
            break;
    case 4: gtk_dialog_add_buttons(dialog, lb[0], id[0], lb[1], id[1], lb[2], id[2], lb[3], id[3], NULL);
            break;
    case 5: gtk_dialog_add_buttons(dialog, lb[0], id[0], lb[1], id[1], lb[2], id[2], lb[3], id[3], lb[4], id[4], NULL);
            break;
    case 6: gtk_dialog_add_buttons(dialog, lb[0], id[0], lb[1], id[1], lb[2], id[2], lb[3], id[3], lb[4], id[4], lb[5], id[5], NULL);
            break;
    case 7: gtk_dialog_add_buttons(dialog, lb[0], id[0], lb[1], id[1], lb[2], id[2], lb[3], id[3], lb[4], id[4], lb[5], id[5], lb[6], id[6], NULL);
            break;
  }
  SCM_RETURN(SCM_UNDEFINED);
#undef MAX_VARARG
  ")
  )

;;==================================================================
;; gtkeditable.h
;;

(input-file "gtkeditable.h")

;; <gtk-editable> is an interface.  It doesn't have structure body,
;; so h2stub doesn't generate an info.

(define-opaque GtkEditable :gobject)
(define-type <gtk-editable> "GtkEditable*" #f
  "SCM_GTK_EDITABLE_P" "SCM_GTK_EDITABLE" "SCM_MAKE_GTK_EDITABLE")

(define-cproc-fix gtk-editable-get-selection-bounds
  (fix-arguments! '(editable::<gtk-editable>))
  (fix-body!
   "gint start = 0, end = 0; gboolean r;
  r = gtk_editable_get_selection_bounds(editable, &start, &end);
  SCM_RETURN3(SCM_MAKE_BOOL(r), SCM_MAKE_INT(start), SCM_MAKE_INT(end));"))

(define-cproc-fix gtk-editable-insert-text
  (fix-arguments! '(editable::<gtk-editable> new-text::<string> position::<int>))
  (fix-body!
   "int len = SCM_STRING_SIZE(new_text);
  gtk_editable_insert_text(editable, (const gchar*)Scm_GetStringConst(new_text), len, &position);
  SCM_RETURN(Scm_MakeInteger(position));"))

;;==================================================================
;; gtkentry.h
;;

(input-file "gtkentry.h")

;; GtkEntry implements GtkEditable interface.   It is not explicitly
;; in the header, so we need to add <gtk-editable> in CPL.
(define-cclass-fix <gtk-entry>
  (add-mixin! "Scm_GtkEditableClass" "Scm_GtkCellEditableClass"))

;; we can't free the return value of gtk_entry_get_text.
(define-cproc-fix gtk-entry-get-text
  (fix-arguments! '(entry::<gtk-entry>))
  (fix-body!
   "SCM_RETURN(SCM_MAKE_STR_COPYING(gtk_entry_get_text(entry)));"))

;;==================================================================
;; gtkfilesel.h
;;

(input-file "gtkfilesel.h")

;; gtk_file_selection_get_filename returns mbstr encoded by the current
;; locale.  We canonicalize it to utf8.  The Scheme glue code converts
;; it to Gauche's internal encoding.
(define-cproc-fix gtk-file-selection-get-filename
  (fix-arguments! '(sel::<gtk-file-selection>))
  (fix-body!
   "const gchar *fn_mb = gtk_file_selection_get_filename(sel);
  gchar *fn_utf8 = g_filename_to_utf8(fn_mb, -1, NULL, NULL, NULL);
  if (fn_utf8 == NULL) {
    Scm_Error(\"got a filename including multibyte chars which can't be converted to UTF8: %s\", fn_mb);
  }
#ifdef GAUCHE_CHAR_ENCODING_UTF_8
  SCM_RETURN(SCM_MAKE_STR_COPYING(fn_utf8));
#else
  SCM_RETURN(Scm_MakeString(fn_utf8, -1, -1, SCM_MAKSTR_COPYING|SCM_MAKSTR_INCOMPLETE));
#endif"))

(define-cproc gtk-file-selection-get-selections (sel::<gtk-file-selection>)
  "gchar **fns_mb = gtk_file_selection_get_selections(sel);
  ScmObj h = SCM_NIL, t = SCM_NIL;
  for (; *fns_mb; fns_mb++) {
    gchar *fn_utf8 = g_filename_to_utf8(*fns_mb, -1, NULL, NULL, NULL);
    if (fn_utf8 == NULL) {
      Scm_Error(\"got a filename including multibyte chars which can't be converted to UTF8: %s\", *fns_mb);
    }
#ifdef GAUCHE_CHAR_ENCODING_UTF_8
    SCM_APPEND(h, t, SCM_MAKE_STR_COPYING(fn_utf8));
#else
    SCM_APPEND(h, t, Scm_MakeString(fn_utf8, -1, -1, SCM_MAKSTR_COPYING|SCM_MAKSTR_INCOMPLETE));
#endif
  }
  g_strfreev(fns_mb);
  SCM_RETURN(h);")

;;==================================================================
;; gtkframe.h
;;

(input-file "gtkframe.h")

;; allow #f to be passed as a label string.
(define-cproc-fix gtk-frame-new
  (fix-arguments! '(label::<const-gchar*>-or-null)))

(define-cproc-fix gtk-frame-set-label
  (fix-arguments!
        '(frame::<gtk-frame> label::<const-gchar*>-or-null)))

;;==================================================================
;; gtkimage.h
;;

(input-file "gtkimage.h")

;; GtkImage is an union.
(define-cclass-fix <gtk-image>
  (ignore-field-except! '(misc storage-type)))

;;==================================================================
;; gtkimmulticontext.h
;;

(input-file "gtkimmulticontext.h")

;; 'client_window' field appears to be dropped in gtk-2.2.4.
(define-cclass-fix <gtk-im-multicontext>
  (ignore-field! 'client-window))

;;==================================================================
;; gtklabel
;;

(input-file "gtklabel.h")

;; Memory is owned by the widget so we don't need to free them.
(define-cproc-fix gtk-label-get-text
  (fix-arguments! '(label::<gtk-label>))
  (fix-body!
   "SCM_RETURN(SCM_MAKE_STR_COPYING(gtk_label_get_text(label)));"))
(define-cproc-fix gtk-label-get-label
  (fix-arguments! '(label::<gtk-label>))
  (fix-body!
   "SCM_RETURN(SCM_MAKE_STR_COPYING(gtk_label_get_label(label)));"))

(define-cproc-fix gtk-label-get-seleciton-bounds
  (fix-arguments! '(label::<gtk-label>))
  (fix-body! "gint start, end;
  gboolean r = gtk_label_get_selection_bounds(label, &start, &end);
  if (r) {
    SCM_RETURN2(Scm_MakeInteger(start), Scm_MakeInteger(end));
  } else {
    SCM_RETURN2(SCM_FALSE, SCM_FALSE);
  }"))

(define-cproc-fix gtk-label-get-layout-offsets
  (fix-arguments! '(label::<gtk-label>))
  (fix-body! "gint x, y;
  gtk_label_get_layout_offsets(label, &x, &y);
  SCM_RETURN2(Scm_MakeInteger(x), Scm_MakeInteger(y));
  "))
 
;;==================================================================
;; gtklayout
;;

(input-file "gtklayout.h")

(define-cproc-fix gtk-layout-new
  (fix-arguments! '(hadjustment::<gtk-adjustment>-or-null
                    vadjustment::<gtk-adjustment>-or-null)))

(define-cproc-fix gtk-layout-get-size
  (fix-arguments! '(layout::<gtk-layout>))
  (fix-body! "gint w, h;
  gtk_layout_get_size(layout, &w, &h);
  SCM_RETURN2(Scm_MakeInteger(w), Scm_MakeInteger(h));
  "))

;;==================================================================
;; gtklist
;;

(input-file "gtklist.h")

(define-cclass-fix <gtk-list>
  (fix-field! 'children
              (set! (accessible? field) #t)
              (set! (getter-of field)
                    "return Scm_GoListToList(obj->children);")
              (set! (setter-of field) #f))
  (fix-field! 'selection
              (set! (accessible? field) #t)
              (set! (getter-of field)
                    "return Scm_GoListToList(obj->selection);")
              (set! (setter-of field) #f))
  (fix-field! 'undo-selection
              (set! (accessible? field) #t)
              (set! (getter-of field)
                    "return Scm_GoListToList(obj->undo_selection);")
              (set! (setter-of field) #f))
  (fix-field! 'undo-unselection
              (set! (accessible? field) #t)
              (set! (getter-of field)
                    "return Scm_GoListToList(obj->undo_unselection);")
              (set! (setter-of field) #f))
  )

(define-cproc-fix gtk-list-insert-items
  (fix-arguments! '(list::<gtk-list> items::<list> position::<int>))
  (fix-body!
   "gtk_list_insert_items(list, Scm_ListToGList(items), position);
    SCM_RETURN(SCM_UNDEFINED);"))

(define-cproc-fix gtk-list-append-items
  (fix-arguments! '(list::<gtk-list> items::<list>))
  (fix-body!
   "gtk_list_append_items(list, Scm_ListToGList(items));
    SCM_RETURN(SCM_UNDEFINED);"))
  
(define-cproc-fix gtk-list-prepend-items
  (fix-arguments! '(list::<gtk-list> items::<list>))
  (fix-body!
   "gtk_list_prepend_items(list, Scm_ListToGList(items));
    SCM_RETURN(SCM_UNDEFINED);"))

(define-cproc-fix gtk-list-remove-items
  (fix-arguments! '(list::<gtk-list> items::<list>))
  (fix-body!
   "gtk_list_remove_items(list, Scm_ListToGList(items));
    SCM_RETURN(SCM_UNDEFINED);"))

;;==================================================================
;; gtkliststore
;;

(input-file "gtkliststore.h")

;; GtkListStore implements GtkTreeModel interface
(define-cclass-fix <gtk-list-store>
  (add-mixin! "Scm_GtkTreeDragSourceClass" "Scm_GtkTreeDragDestClass"
              "Scm_GtkTreeSortableClass" "Scm_GtkTreeModelClass"))

;; Many functions in liststore takes varargs --- should be writtin in Scheme.
(define-cproc-fix gtk-list-store-new
  (fix-arguments! '(&rest types))
  (fix-body!
        "GType gtypes_static[32], *gtypes = gtypes_static; int len;
  if ((len = Scm_Length(types)) > 32) 
     gtypes = SCM_NEW_ATOMIC2(GType*, len*sizeof(GType));
  Scm_ClassListToGtkTypeList(types, gtypes);
  SCM_RETURN(SCM_MAKE_GTK_LIST_STORE(gtk_list_store_newv(len, gtypes)));"))

(define-cproc-fix gtk-list-store-newv
  (fix-arguments! '(types::<vector>))
  (fix-body!
        "GType gtypes_static[32], *gtypes = gtypes_static; int len;
  if ((len = SCM_VECTOR_SIZE(types)) > 32) 
     gtypes = SCM_NEW_ATOMIC2(GType*, len*sizeof(GType));
  Scm_ClassListToGtkTypeList(SCM_OBJ(types), gtypes);
  SCM_RETURN(SCM_MAKE_GTK_LIST_STORE(gtk_list_store_newv(len, gtypes)));"))
  
(define-cproc-fix gtk-list-store-set-column-types
  (fix-arguments! '(list-store::<gtk-list-store> types))
  (fix-body!
        "GType gtypes_static[32], *gtypes = gtypes_static; int len;
  if ((len = Scm_Length(types)) < 0) {
     if (SCM_VECTORP(types)) {
        len = SCM_VECTOR_SIZE(types);
     } else {
        Scm_Error(\"list or vector of <class> required, but got %S\", types);
     }
  }
  if (len > 32) gtypes = SCM_NEW_ATOMIC2(GType*, len*sizeof(GType));
  Scm_ClassListToGtkTypeList(SCM_OBJ(types), gtypes);
  gtk_list_store_set_column_types(list_store, len, gtypes);
  SCM_RETURN(SCM_UNDEFINED);"))

(define-cproc-fix gtk-list-store-set-value
  (fix-arguments! '(list-store::<gtk-list-store>
                              iter::<gtk-tree-iter>
                              column::<fixnum>
                              value))
  (fix-body!
        "GValue gval; gval.g_type = 0;
  gtk_list_store_set_value(list_store, iter, column,
                           Scm_ObjToGValue(value, &gval));
  g_value_unset(&gval);
  SCM_RETURN(SCM_UNDEFINED);"))

(define-cproc-fix gtk-list-store-append
  (fix-arguments! '(list-store::<gtk-list-store>))
  (fix-body!
        "GtkTreeIter iter;
  gtk_list_store_append(list_store, &iter);
  SCM_RETURN(SCM_MAKE_GTK_TREE_ITER(&iter));"))

(define-cproc-fix gtk-list-store-prepend
  (fix-arguments! '(list-store::<gtk-list-store>))
  (fix-body!
        "GtkTreeIter iter;
  gtk_list_store_prepend(list_store, &iter);
  SCM_RETURN(SCM_MAKE_GTK_TREE_ITER(&iter));"))

;; gtk-list-store-remove

(define-cproc-fix gtk-list-store-insert
  (fix-arguments!
        '(list-store::<gtk-list-store> position::<int>))
  (fix-body!
        "GtkTreeIter iter;
  gtk_list_store_insert(list_store, &iter, position);
  SCM_RETURN(SCM_MAKE_GTK_TREE_ITER(&iter));"))

(define-cproc-fix gtk-list-store-insert-before
  (fix-arguments!
        '(list-store::<gtk-list-store> sibling::<gtk-tree-iter>-or-null))
  (fix-body!
        "GtkTreeIter iter;
  gtk_list_store_insert_before(list_store, &iter, sibling);
  SCM_RETURN(SCM_MAKE_GTK_TREE_ITER(&iter));"))

(define-cproc-fix gtk-list-store-insert-after
  (fix-arguments!
        '(list-store::<gtk-list-store> sibling::<gtk-tree-iter>-or-null))
  (fix-body!
        "GtkTreeIter iter;
  gtk_list_store_insert_after(list_store, &iter, sibling);
  SCM_RETURN(SCM_MAKE_GTK_TREE_ITER(&iter));"))

;;==================================================================
;; gtkmain
;;

(input-file "gtkmain.h")

;; gtk_check_version

;; gtk_init
(define-cproc-fix gtk-init
  (fix-arguments! (list 'args))
  (fix-body!
        "gint argc; gchar **argv;
  argc = Scm_GtkStringsToGcharArrays(args, &argv);
  gtk_init(&argc, &argv);
  SCM_RETURN(Scm_GtkGcharArraysToStrings(argc, argv));")
  )

;; gtk_init_check
(define-cproc-fix gtk-init-check
  (fix-arguments! (list 'args))
  (fix-body!
        "gint argc; gchar **argv; gboolean r;
  argc = Scm_GtkStringsToGcharArrays(args, &argv);
  r = gtk_init_check(&argc, &argv);
  if (r) SCM_RETURN(Scm_GtkGcharArraysToStrings(argc, argv));
  else   SCM_RETURN(SCM_FALSE);")
  )

;; gtk_init_abi_check
;; gtk_init_check_abk_check

;; gtk_set_locale
(define-cproc-fix gtk-set-locale
  (fix-arguments! (list 'args))
  (fix-body!
   "gchar *locale = gtk_set_locale();
  ScmObj s = SCM_MAKE_STR_COPYING((char*)locale);
  g_free(locale);
  SCM_RETURN(s);")
  )

;; gtk_get_default_language

;; mmc:  
(define-cproc-fix gtk-check-version
  ;; fixme:  nicer:  (return <const-gchar*>-or-null
  (fix-body!
   "gchar* string = gtk_check_version(required_major, required_minor, required_micro);
if (string == NULL)
    return SCM_FALSE;
return SCM_MAKE_STR_COPYING((char*)string);"))


;; gtk_init_add
(define-cproc-fix gtk-init-add
  (fix-arguments! '(proc::<procedure>))
  (fix-body!
   "Scm_GtkProtect(SCM_OBJ(proc));
    gtk_init_add(Scm_GtkCallThunk, proc); SCM_RETURN(SCM_UNDEFINED);")
  )

;; gtk_quit_add, gtk_quit_add_full - integrated
(define-cproc-fix gtk-quit-add
  (fix-arguments! '(main-level::<uint> proc::<procedure>))
  (fix-body!
   "Scm_GtkProtect(SCM_OBJ(proc));
    SCM_RETURN(Scm_MakeIntegerU(gtk_quit_add_full(main_level, Scm_GtkCallThunk, NULL, proc, Scm_GtkUnprotect)));")
  )

;; gtk_quit_remove_by_data
(define-cproc-fix gtk-quit-remove-by-data
  (fix-arguments! '(proc))
  (fix-body!
   "gtk_quit_remove_by_data(proc); SCM_RETURN(SCM_UNDEFINED);")
  )

;; gtk_timeout_add,  gtk_timeout_add_full - integrated
(define-cproc-fix gtk-timeout-add
  (fix-arguments! '(interval::<ulong> proc::<procedure>))
  (fix-body!
   "Scm_GtkProtect(SCM_OBJ(proc));
    SCM_RETURN(Scm_MakeIntegerU(gtk_timeout_add_full(interval, Scm_GtkCallThunk, NULL, proc, Scm_GtkUnprotect)));")
  )

;; gtk_idle_add
;; gtk_idle_add_priority
;; gtk_idle_add_full
(define-cproc-fix gtk-idle-add
  (fix-arguments! '(proc::<procedure>))
  (fix-body!
   "Scm_GtkProtect(SCM_OBJ(proc));
    SCM_RETURN(Scm_MakeIntegerU(gtk_idle_add_full(GTK_PRIORITY_DEFAULT, Scm_GtkCallThunk, NULL, proc, Scm_GtkUnprotect)));")
  )

(define-cproc-fix gtk-idle-add-priority
  (fix-arguments! '(priority::<int> proc::<procedure>))
  (fix-body!
   "Scm_GtkProtect(SCM_OBJ(proc));
    SCM_RETURN(Scm_MakeIntegerU(gtk_idle_add_full(priority, Scm_GtkCallThunk, NULL, proc, Scm_GtkUnprotect)));")
  )

;; gtk_idle_remove_by_data
(define-cproc-fix gtk-idle-remove-by-data
  (fix-arguments! '(proc))
  (fix-body!
   "gtk_idle_remove_by_data(proc); SCM_RETURN(SCM_UNDEFINED);")
  )

;; gtk_input_add_full

(raw-code
 "static void call_input_function(gpointer data, gint source,
                                  GdkInputCondition condition)
 {
    ScmObj p = SCM_OBJ(data), closure, port;
    SCM_ASSERT(SCM_PAIRP(p));
    closure = SCM_CAR(p);
    port = SCM_CDR(p);
    Scm_GtkApply(closure, SCM_LIST2(port, SCM_MAKE_INT(condition)));
 }")

(define-cproc gtk-input-add (source condition::<int> proc)
  "int fd = Scm_GetPortFd(source, TRUE);
  ScmObj data = Scm_Cons(proc, source);
  Scm_GtkProtect(data);
  SCM_RETURN(Scm_MakeIntegerU(gtk_input_add_full(fd, condition, call_input_function, NULL, data, Scm_GtkUnprotect)));")

(disable-cproc gtk-input-add-full)

;; gtk_key_snooper_install

;; gtk_get_current_event_state
(define-cproc-fix gtk-get-current-event-state
  (fix-arguments! '())
  (fix-body!
   "GdkModifierType type = 0; gboolean r;
  r = gtk_get_current_event_state(&type);
  SCM_RETURN2(SCM_MAKE_BOOL(r), Scm_MakeIntegerU(type));")
  )

;;==================================================================
;; gtkmenu
;;

(input-file "gtkmenu.h")

; gtk-menu-popup
(raw-code
 "static void menu_position_func_caller(GtkMenu *m, gint *x, gint *y, gboolean *push_in, gpointer data)
 {
    ScmObj func = SCM_OBJ(data), r;
    SCM_ASSERT(SCM_PROCEDUREP(func));
    r = Scm_GtkApply(func, SCM_LIST1(Scm_MakeGObject(G_OBJECT(m))));
    *x = 0; *y = 0; *push_in = FALSE;
    if (Scm_Length(r) != 3) {
       Scm_Warn(\"gtk-menu-popup manu position callback %S returned bad number of values (%d), which is supposed to be 3.  The result is ignored.\", func, Scm_Length(r));
       return;
    }
    if (!SCM_INTP(SCM_CAR(r))) {
       Scm_Warn(\"gtk-menu-popup manu position callback %S returned bad type of value %S as the first return value, which is supposed to be an integer.  The result is ignored.\", func, SCM_CAR(r));
       return;
    }
    *x = SCM_INT_VALUE(SCM_CADR(r));
    if (!SCM_INTP(SCM_CADR(r))) {
       Scm_Warn(\"gtk-menu-popup manu position callback %S returned bad type of value %S as the second return value, which is supposed to be an integer.  The result is ignored.\", func, SCM_CADR(r));
       return;
    }
    *y = SCM_INT_VALUE(SCM_CADR(r));
    *push_in = SCM_BOOL_VALUE(SCM_CAR(SCM_CDDR(r)));
 }"

 "#define MENU_CB_KEY \"ScmMenuCB\""
 )

(define-cproc-fix gtk-menu-popup
  (fix-arguments! '(menu::<gtk-menu>
                    parent_menu_shell::<gtk-widget>-or-null
                    parent_menu_item::<gtk-widget>-or-null
                    func
                    button::<uint>
                    activate_time::<ulong>))
  (fix-body!
   "
  if (SCM_PROCEDUREP(func)) {
      Scm_GtkProtect(func);
      g_object_set_data_full(G_OBJECT(menu), MENU_CB_KEY, func,
                             (GDestroyNotify)Scm_GtkUnprotect);
      gtk_menu_popup(menu, parent_menu_shell, parent_menu_item,
                     menu_position_func_caller, func, button, activate_time);
  } else if (!SCM_FALSEP(func)) {
      Scm_Error(\"procedure or #f required, but got %S\", func);
  } else {
      g_object_set_data(G_OBJECT(menu), MENU_CB_KEY, NULL);
      gtk_menu_popup(menu, parent_menu_shell, parent_menu_item,
                     NULL, NULL, button, activate_time);
  }
  SCM_RETURN(SCM_UNDEFINED);"))

; gtk-menu-attach-to-widget

;;==================================================================
;; gtkmessagedialog
;;

(input-file "gtkmessagedialog.h")

;; unlike C-api, this accepts just a message string.
(define-cproc-fix gtk-message-dialog-new
  (fix-arguments! '(parent::<gtk-window>-or-null
                    flags::<int>
                    type::<int>
                    buttons::<int>
                    message::<string>))
  (fix-body!
   "SCM_RETURN(SCM_MAKE_GTK_WIDGET(
       gtk_message_dialog_new(parent, flags, type, buttons, \"%s\", message)));"))

#|
;; this isn't in Gtk2.2.1
(define-cproc-fix gtk-message-dialog-new-with-markup
  (fix-arguments! '(parent::<gtk-window>-or-null
                    flags::<int>
                    type::<int>
                    buttons::<int>
                    message::<string>))
  (fix-body!
        "SCM_RETURN(SCM_MAKE_GTK_WIDGET(
            gtk_message_dialog_new_with_markup(parent, flags, type, buttons,
                                               \"%s\", message)));"))
|#

;;==================================================================
;; gtkmisc
;;

(input-file "gtkmisc.h")

(define-cproc-fix gtk-misc-get-alignment
  (fix-arguments! '(misc::<gtk-misc>))
  (fix-body!
   "gfloat xalign, yalign;
  gtk_misc_get_alignment(misc, &xalign, &yalign);
  SCM_RETURN2(Scm_MakeFlonum(xalign), Scm_MakeFlonum(yalign));"))

(define-cproc-fix gtk-misc-get-padding
  (fix-arguments! '(misc::<gtk-misc>))
  (fix-body!
   "gint xpad, ypad;
  gtk_misc_get_padding(misc, &xpad, &ypad);
  SCM_RETURN2(Scm_MakeInteger(xpad), Scm_MakeInteger(ypad));"))

;;==================================================================
;; gtknotebook
;;

(input-file "gtknotebook.h")

(define-cproc-fix gtk-notebook-query-tab-label-packing
  (fix-arguments! '(notebook::<gtk-notebook> child::<gtk-widget>))
  (fix-body!
   "gboolean expand, fill; GtkPackType pack_type;
  gtk_notebook_query_tab_label_packing(notebook, child, &expand, &fill, &pack_type);
  SCM_RETURN3(SCM_MAKE_BOOL(expand), SCM_MAKE_BOOL(fill), Scm_MakeInteger(pack_type));"))

;;==================================================================
;; gtkpaned
;;

(input-file "gtkpaned.h")

;; GtkPaned - saved-focus is deprecated in GTk-2.2
(define-cclass-fix <gtk-paned>
  (ignore-field! 'saved-focus))

;;==================================================================
;; gtkpixmap
;;

(input-file "gtkpixmap.h")

(define-cproc-fix gtk-pixmap-get
  (fix-arguments! '(pixmap::<gtk-pixmap>))
  (fix-body!
   "GdkPixmap *val; GdkBitmap *mask;
  gtk_pixmap_get(pixmap, &val, &mask);
  SCM_RETURN2(SCM_MAKE_GDK_DRAWABLE(val), SCM_MAKE_GDK_DRAWABLE(mask));"))

;;==================================================================
;; gtkproperty
;;

(input-file "gdkproperty.h")

;; gdk-property-get : the Gtk+ manual recommend to avoid using this, 
;; so we don't implement it.
(disable-cproc gdk-property-get)

;; gdk-property-change : receives either u8vector, u16vector, or u32vector
;; as data.  'format' and 'nelements' args are determined
;; derived from it.
(define-cproc-fix gdk-property-change
  (fix-arguments! '(window::<gdk-drawable>
                    property::<gdk-atom>
                    type::<gdk-atom>
                    mode::<int>
                    data))
  (fix-body! "int format, nelements; guchar *d;
  d = Scm_GdkPropertyDataFromUVector(data, &format, &nelements);
  gdk_property_change(window, property, type, format, mode, d, nelements);
  SCM_RETURN(SCM_UNDEFINED);"))

;; we don't need this
(disable-cproc gdk-free-text-list)
(disable-cproc gdk-free-compound-text)

;;==================================================================
;; gtkprogressbar
;;

(input-file "gtkprogressbar.h")

(define-cproc-fix gtk-progress-bar-get-text
  (fix-arguments! '(pbar::<gtk-progress-bar>))
  (fix-body!
   "gchar *g = gtk_progress_bar_get_text(pbar);
  SCM_RETURN(SCM_MAKE_STR_COPYING_SAFELY(g));"))

;;==================================================================
;; gtkradiobutton
;;

(input-file "gtkradiobutton.h")

(define-cproc-fix gtk-radio-button-new
  (fix-arguments! '(group))
  (fix-body!
   "GSList *glist = Scm_GtkRadioGroupGetGroup(group);
  SCM_RETURN(Scm_MakeGObject(G_OBJECT(gtk_radio_button_new(glist))));"))

(define-cproc-fix gtk-radio-button-new-with-label
  (fix-arguments! '(group label::<const-gchar*>))
  (fix-body!
   "SCM_RETURN(Scm_MakeGObject(G_OBJECT(gtk_radio_button_new_with_label(Scm_GtkRadioGroupGetGroup(group), label))));"))

(define-cproc-fix gtk-radio-button-new-with-mnemonic
  (fix-arguments! '(group label::<const-gchar*>))
  (fix-body!
   "SCM_RETURN(Scm_MakeGObject(G_OBJECT(gtk_radio_button_new_with_mnemonic(Scm_GtkRadioGroupGetGroup(group), label))));"))

(define-cproc-fix gtk-radio-button-get-group
  (fix-arguments! '(radio-button::<gtk-radio-button>))
  (fix-body!
   "SCM_RETURN(Scm_MakeGtkRadioGroup(G_OBJECT(radio_button)));"))

(define-cproc-fix gtk-radio-button-set-group
  (fix-arguments! '(radio-button::<gtk-radio-button> group))
  (fix-body!
   "GSList *glist = Scm_GtkRadioGroupGetGroup(group);
  if (glist && !GTK_IS_RADIO_BUTTON(glist->data)) {
    Scm_Error(\"element of radio group %S is not a radio button\", group);
  }
  gtk_radio_button_set_group(radio_button, glist);
  SCM_RETURN(SCM_UNDEFINED);"))

(define-cproc gtk-radio-group->list (group::<gtk-radio-group>)
  (call <top> "Scm_GtkRadioGroupToList"))

;;==================================================================
;; gtkradiomenuitem
;;

(input-file "gtkradiomenuitem.h")

(define-cproc-fix gtk-radio-menu-item-new
  (fix-arguments! '(group))
  (fix-body!
   "GSList *glist = Scm_GtkRadioGroupGetGroup(group);
  SCM_RETURN(Scm_MakeGObject(G_OBJECT(gtk_radio_menu_item_new(glist))));"))

(define-cproc-fix gtk-radio-menu-item-new-with-label
  (fix-arguments! '(group label::<const-gchar*>))
  (fix-body!
   "SCM_RETURN(Scm_MakeGObject(G_OBJECT(gtk_radio_menu_item_new_with_label(Scm_GtkRadioGroupGetGroup(group), label))));"))

(define-cproc-fix gtk-radio-menu-item-new-with-mnemonic
  (fix-arguments! '(group label::<const-gchar*>))
  (fix-body!
   "SCM_RETURN(Scm_MakeGObject(G_OBJECT(gtk_radio_menu_item_new_with_mnemonic(Scm_GtkRadioGroupGetGroup(group), label))));"))

(define-cproc-fix gtk-radio-menu-item-get-group
  (fix-arguments! '(radio-menu-item::<gtk-radio-menu-item>))
  (fix-body!
   "SCM_RETURN(Scm_MakeGtkRadioGroup(G_OBJECT(radio_menu_item)));"))

(define-cproc-fix gtk-radio-menu-item-set-group
  (fix-arguments! '(radio-menu-item::<gtk-radio-menu-item> group))
  (fix-body!
   "GSList *glist = Scm_GtkRadioGroupGetGroup(group); 
  if (glist && !GTK_IS_RADIO_MENU_ITEM(glist->data)) {
    Scm_Error(\"element of radio group %S is not a radio menu item\", group);
  }
  gtk_radio_menu_item_set_group(radio_menu_item, glist);
  SCM_RETURN(SCM_UNDEFINED);"))

;;==================================================================
;; gtkscrolledwindow
;;

(input-file "gtkscrooledwindow.h")

;; allow NULL for the argument of gtk-scrolled-window-new
(define-cproc-fix gtk-scrolled-window-new
  (fix-arguments! '(hadj::<gtk-adjustment>-or-null vadj::<gtk-adjustment>-or-null))
  )

;;==================================================================
;; gtkspinbutton
;;

(input-file "gtkspinbutton.h")

(define-cproc-fix gtk-spin-button-get-increments
  (fix-arguments! '(spin_button::<gtk-spin-button>))
  (fix-body! "gdouble step, page;
  gtk_spin_button_get_range(spin_button, &step, &page);
  SCM_RETURN2(Scm_MakeFlonum(step), Scm_MakeFlonum(page));"))

(define-cproc-fix gtk-spin-button-get-range
  (fix-arguments! '(spin_button::<gtk-spin-button>))
  (fix-body! "gdouble min, max;
  gtk_spin_button_get_range(spin_button, &min, &max);
  SCM_RETURN2(Scm_MakeFlonum(min), Scm_MakeFlonum(max));"))

;;==================================================================
;; gtkstock
;;

(input-file "gtkstock.h")

;; stock IDs.  these are #defined strings and can't be captured by h2stub.
(define-constant GTK_STOCK_DIALOG_INFO      "gtk-dialog-info")
(define-constant GTK_STOCK_DIALOG_WARNING   "gtk-dialog-warning")
(define-constant GTK_STOCK_DIALOG_ERROR     "gtk-dialog-error")
(define-constant GTK_STOCK_DIALOG_QUESTION  "gtk-dialog-question")

(define-constant GTK_STOCK_DND              "gtk-dnd")
(define-constant GTK_STOCK_DND_MULTIPLE     "gtk-dnd-multiple")

(define-constant GTK_STOCK_ADD              "gtk-add")
(define-constant GTK_STOCK_APPLY            "gtk-apply")
(define-constant GTK_STOCK_BOLD             "gtk-bold")
(define-constant GTK_STOCK_CANCEL           "gtk-cancel")
(define-constant GTK_STOCK_CDROM            "gtk-cdrom")
(define-constant GTK_STOCK_CLEAR            "gtk-clear")
(define-constant GTK_STOCK_CLOSE            "gtk-close")
(define-constant GTK_STOCK_CONVERT          "gtk-convert")
(define-constant GTK_STOCK_COPY             "gtk-copy")
(define-constant GTK_STOCK_CUT              "gtk-cut")
(define-constant GTK_STOCK_DELETE           "gtk-delete")
(define-constant GTK_STOCK_EXECUTE          "gtk-execute")
(define-constant GTK_STOCK_FIND             "gtk-find")
(define-constant GTK_STOCK_FIND_AND_REPLACE "gtk-find-and-replace")
(define-constant GTK_STOCK_FLOPPY           "gtk-floppy")
(define-constant GTK_STOCK_GOTO_BOTTOM      "gtk-goto-bottom")
(define-constant GTK_STOCK_GOTO_FIRST       "gtk-goto-first")
(define-constant GTK_STOCK_GOTO_LAST        "gtk-goto-last")
(define-constant GTK_STOCK_GOTO_TOP         "gtk-goto-top")
(define-constant GTK_STOCK_GO_BACK          "gtk-go-back")
(define-constant GTK_STOCK_GO_DOWN          "gtk-go-down")
(define-constant GTK_STOCK_GO_FORWARD       "gtk-go-forward")
(define-constant GTK_STOCK_GO_UP            "gtk-go-up")
(define-constant GTK_STOCK_HELP             "gtk-help")
(define-constant GTK_STOCK_HOME             "gtk-home")
(define-constant GTK_STOCK_INDEX            "gtk-index")
(define-constant GTK_STOCK_ITALIC           "gtk-italic")
(define-constant GTK_STOCK_JUMP_TO          "gtk-jump-to")
(define-constant GTK_STOCK_JUSTIFY_CENTER   "gtk-justify-center")
(define-constant GTK_STOCK_JUSTIFY_FILL     "gtk-justify-fill")
(define-constant GTK_STOCK_JUSTIFY_LEFT     "gtk-justify-left")
(define-constant GTK_STOCK_JUSTIFY_RIGHT    "gtk-justify-right")
(define-constant GTK_STOCK_MISSING_IMAGE    "gtk-missing-image")
(define-constant GTK_STOCK_NEW              "gtk-new")
(define-constant GTK_STOCK_NO               "gtk-no")
(define-constant GTK_STOCK_OK               "gtk-ok")
(define-constant GTK_STOCK_OPEN             "gtk-open")
(define-constant GTK_STOCK_PASTE            "gtk-paste")
(define-constant GTK_STOCK_PREFERENCES      "gtk-preferences")
(define-constant GTK_STOCK_PRINT            "gtk-print")
(define-constant GTK_STOCK_PRINT_PREVIEW    "gtk-print-preview")
(define-constant GTK_STOCK_PROPERTIES       "gtk-properties")
(define-constant GTK_STOCK_QUIT             "gtk-quit")
(define-constant GTK_STOCK_REDO             "gtk-redo")
(define-constant GTK_STOCK_REFRESH          "gtk-refresh")
(define-constant GTK_STOCK_REMOVE           "gtk-remove")
(define-constant GTK_STOCK_REVERT_TO_SAVED  "gtk-revert-to-saved")
(define-constant GTK_STOCK_SAVE             "gtk-save")
(define-constant GTK_STOCK_SAVE_AS          "gtk-save-as")
(define-constant GTK_STOCK_SELECT_COLOR     "gtk-select-color")
(define-constant GTK_STOCK_SELECT_FONT      "gtk-select-font")
(define-constant GTK_STOCK_SORT_ASCENDING   "gtk-sort-ascending")
(define-constant GTK_STOCK_SORT_DESCENDING  "gtk-sort-descending")
(define-constant GTK_STOCK_SPELL_CHECK      "gtk-spell-check")
(define-constant GTK_STOCK_STOP             "gtk-stop")
(define-constant GTK_STOCK_STRIKETHROUGH    "gtk-strikethrough")
(define-constant GTK_STOCK_UNDELETE         "gtk-undelete")
(define-constant GTK_STOCK_UNDERLINE        "gtk-underline")
(define-constant GTK_STOCK_UNDO             "gtk-undo")
(define-constant GTK_STOCK_YES              "gtk-yes")
(define-constant GTK_STOCK_ZOOM_100         "gtk-zoom-100")
(define-constant GTK_STOCK_ZOOM_FIT         "gtk-zoom-fit")
(define-constant GTK_STOCK_ZOOM_IN          "gtk-zoom-in")
(define-constant GTK_STOCK_ZOOM_OUT         "gtk-zoom-out")

;;==================================================================
;; gtktextbuffer
;;

(input-file "gtktextbuffer.h")

;; gtk_text_buffer_create_tag - written in Scheme

(define-cproc-fix gtk-text-buffer-get-iter-at-line-offset
  (fix-arguments!
   '(buffer::<gtk-text-buffer> line_number::<int> char_offset::<int>))
  (fix-body!
   "GtkTextIter iter;
    gtk_text_buffer_get_iter_at_line_offset(buffer, &iter, line_number, char_offset);
    SCM_RETURN(SCM_MAKE_GTK_TEXT_ITER(&iter));"))

(define-cproc-fix gtk-text-buffer-get-iter-at-line-index
  (fix-arguments!
   '(buffer::<gtk-text-buffer> line_number::<int> byte_index::<int>))
  (fix-body!
   "GtkTextIter iter;
    gtk_text_buffer_get_iter_at_line_index(buffer, &iter, line_number, byte_index);
    SCM_RETURN(SCM_MAKE_GTK_TEXT_ITER(&iter));"))

(define-cproc-fix gtk-text-buffer-get-iter-at-offset
  (fix-arguments! '(buffer::<gtk-text-buffer> char_offset::<int>))
  (fix-body!
   "GtkTextIter iter;
    gtk_text_buffer_get_iter_at_offset(buffer, &iter, char_offset);
    SCM_RETURN(SCM_MAKE_GTK_TEXT_ITER(&iter));"))

(define-cproc-fix gtk-text-buffer-get-iter-at-line
  (fix-arguments! '(buffer::<gtk-text-buffer> line_number::<int>))
  (fix-body!
   "GtkTextIter iter;
    gtk_text_buffer_get_iter_at_line(buffer, &iter, line_number);
    SCM_RETURN(SCM_MAKE_GTK_TEXT_ITER(&iter));"))

(define-cproc-fix gtk-text-buffer-get-start-iter
  (fix-arguments! '(buffer::<gtk-text-buffer>))
  (fix-body!
   "GtkTextIter iter;
    gtk_text_buffer_get_start_iter(buffer, &iter);
    SCM_RETURN(SCM_MAKE_GTK_TEXT_ITER(&iter));"))

(define-cproc-fix gtk-text-buffer-get-end-iter
  (fix-arguments! '(buffer::<gtk-text-buffer>))
  (fix-body!
   "GtkTextIter iter;
    gtk_text_buffer_get_end_iter(buffer, &iter);
    SCM_RETURN(SCM_MAKE_GTK_TEXT_ITER(&iter));"))

(define-cproc-fix gtk-text-buffer-get-bounds
  (fix-arguments! '(buffer::<gtk-text-buffer>))
  (fix-body!
   "GtkTextIter start, end;
    gtk_text_buffer_get_bounds(buffer, &start, &end);
    SCM_RETURN2(SCM_MAKE_GTK_TEXT_ITER(&start), SCM_MAKE_GTK_TEXT_ITER(&end));"))

(define-cproc-fix gtk-text-buffer-get-iter-at-mark
  (fix-arguments! '(buffer::<gtk-text-buffer> mark::<gtk-text-mark>))
  (fix-body!
   "GtkTextIter iter;
    gtk_text_buffer_get_iter_at_mark(buffer, &iter, mark);
    SCM_RETURN(SCM_MAKE_GTK_TEXT_ITER(&iter));"))

(define-cproc-fix gtk-text-buffer-get-iter-at-child-anchor
  (fix-arguments! '(buffer::<gtk-text-buffer> anchor::<gtk-text-child-anchor>))
  (fix-body!
   "GtkTextIter iter;
    gtk_text_buffer_get_iter_at_child_anchor(buffer, &iter, anchor);
    SCM_RETURN(SCM_MAKE_GTK_TEXT_ITER(&iter));"))

;;==================================================================
;; gtktextview
;;

(input-file "gtktextview.h")

;; GtkTextView
;;  - ignores some slots that are removed in the recent gtk versions.
(define-cclass-fix <gtk-text-view>
  (ignore-field! 'disable-scroll-on-focus)
  (ignore-field! 'just-selected-element)
  (ignore-field! 'reserved2))

(define-cproc-fix gtk-text-view-get-visible-rect
  (fix-arguments! '(view::<gtk-text-view>))
  (fix-body!
   "GdkRectangle rect;
    gtk_text_view_get_visible_rect(view, &rect);
    SCM_RETURN(SCM_MAKE_GDK_RECTANGLE(&rect));"))

(define-cproc-fix gtk-text-view-get-iter-location
  (fix-arguments! '(view::<gtk-text-view> iter::<gtk-text-iter>))
  (fix-body!
   "GdkRectangle location;
    gtk_text_view_get_iter_location(view, iter, &location);
    SCM_RETURN(SCM_MAKE_GDK_RECTANGLE(&location));"))

(define-cproc-fix gtk-text-view-get-iter-at-location
  (fix-arguments! '(view::<gtk-text-view> x::<int> y::<int>))
  (fix-body!
   "GtkTextIter iter;
    gtk_text_view_get_iter_at_location(view, &iter, x, y);
    SCM_RETURN(SCM_MAKE_GTK_TEXT_ITER(&iter));"))

(define-cproc-fix gtk-text-view-get-line-yrange
  (fix-arguments! '(view::<gtk-text-view> iter::<gtk-text-iter>))
  (fix-body!
   "gint y, height;
    gtk_text_view_get_line_yrange(view, iter, &y, &height);
    SCM_RETURN2(SCM_MAKE_INT(y), SCM_MAKE_INT(height));"))

(define-cproc-fix gtk-text-view-get-line-at-y
  (fix-arguments! '(view::<gtk-text-view> y::<int>))
  (fix-body!
   "GtkTextIter iter; gint top;
    gtk_text_view_get_line_at_y(view, &iter, y, &top);
    SCM_RETURN2(SCM_MAKE_GTK_TEXT_ITER(&iter), SCM_MAKE_INT(top));"))

(define-cproc-fix gtk-text-view-buffer-to-window-coords
  (fix-arguments!
   '(view::<gtk-text-view> win::<int> buffer-x::<int> buffer-y::<int>))
  (fix-body!
   "gint window_x, window_y;
    gtk_text_view_buffer_to_window_coords(view, win, buffer_x, buffer_y,
                                          &window_x, &window_y);
    SCM_RETURN2(SCM_MAKE_INT(window_x), SCM_MAKE_INT(window_y));"))

(define-cproc-fix gtk-text-view-window-to-buffer-coords
  (fix-arguments!
   '(view::<gtk-text-view> win::<int> window-x::<int> window-y::<int>))
  (fix-body!
   "gint buffer_x, buffer_y;
    gtk_text_view_window_to_buffer_coords(view, win, window_x, window_y,
                                          &buffer_x, &buffer_y);
    SCM_RETURN2(SCM_MAKE_INT(buffer_x), SCM_MAKE_INT(buffer_y));"))

;;TOOD: get-tabs/set-tabs - needs PangoTabArray


;;==================================================================
;; gtktoolbar
;;mmc:   disable them b/c  deprecated.  They don't build anyway.
(disable-cproc gtk-toolbar-append-element)
(disable-cproc gtk-toolbar-prepend-element)

(disable-cproc gtk-toolbar-append-item)
(disable-cproc gtk-toolbar-prepend-item)
(disable-cproc gtk-toolbar-insert-item)
(disable-cproc gtk-toolbar-insert-stock)



;;==================================================================
;; gtktreednd
;;

(input-file "gtktreednd.h")

;; disable *Iface
(disable-cclass <gtk-tree-drag-source-iface>)
(disable-cclass <gtk-tree-drag-dest-iface>)

(define-opaque GtkTreeDragSource :gobject)
(define-opaque GtkTreeDragDest :gobject)

;;==================================================================
;; gtktreemodel
;;

(input-file "gtktreemodel.h")

;; disable GtkTreeModelIface
(disable-cclass <gtk-tree-model-iface>)

;; interface class
(define-opaque GtkTreeModel :gobject)
(define-type <gtk-tree-model> "GtkTreeModel*" #f
  "SCM_GTK_TREE_MODEL_P" "SCM_GTK_TREE_MODEL" "SCM_MAKE_GTK_TREE_MODEL")

(define-opaque GtkTreePath :indirect)
(define-cclass-fix <gtk-tree-path>
  (set! (c-copy-proc-of self) "gtk_tree_path_copy")
  (set! (c-free-proc-of self) "gtk_tree_path_free"))
(define-type <gtk-tree-path> "GtkTreePath*" #f
  "SCM_GTK_TREE_PATH_P" "SCM_GTK_TREE_PATH" "SCM_MAKE_GTK_TREE_PATH")
(disable-cproc gtk-tree-path-copy)

;; TODO: there's a something wrong w/ memory management here.
(define-opaque GtkTreeRowReference :indirect)
(define-cclass-fix <gtk-tree-row-reference>
  (set! (c-free-proc-of self) "gtk_tree_row_reference_free"))
(define-type <gtk-tree-row-reference> "GtkTreeRowReference*" #f
  "SCM_GTK_TREE_ROW_REFERENCE_P" "SCM_GTK_TREE_ROW_REFERENCE"
  "SCM_MAKE_GTK_TREE_ROW_REFERENCE")

(define-cproc-fix gtk-tree-path-get-indices
  (fix-arguments! '(path::<gtk-tree-path>))
  (fix-body!
   "int depth = gtk_tree_path_get_depth(path);
    int *r = gtk_tree_path_get_indices(path), i;
    ScmObj h = SCM_NIL, t = SCM_NIL;
    for (i=0; i<depth; i++) {
      SCM_APPEND1(h, t, Scm_MakeInteger(r[i]));
    }
    SCM_RETURN(h);"))

(disable-cproc gtk-tree-path-free)

(disable-cproc gtk-tree-row-reference-free)

(define-cproc-fix gtk-tree-model-get-column-type
  (fix-body!
   "SCM_RETURN(SCM_OBJ(Scm_GtkTypeToScmClass(gtk_tree_model_get_column_type(tree_model, index))));"))

(define-cproc-fix gtk-tree-model-get-iter 
  (fix-arguments! '(model::<gtk-tree-model> path::<gtk-tree-path>))
  (fix-body!
   "GtkTreeIter iter; gboolean r;
    r= gtk_tree_model_get_iter(model, &iter, path);
    if (r) SCM_RETURN(SCM_MAKE_GTK_TREE_ITER(&iter));
    else SCM_RETURN(SCM_FALSE);"))

(define-cproc-fix gtk-tree-model-get-iter-from-string
  (fix-arguments! '(model::<gtk-tree-model> path-string::<const-gchar*>))
  (fix-body!
   "GtkTreeIter iter; gboolean r;
    r= gtk_tree_model_get_iter_from_string(model, &iter, path_string);
    if (r) SCM_RETURN(SCM_MAKE_GTK_TREE_ITER(&iter));
    else SCM_RETURN(SCM_FALSE);"))

(define-cproc-fix gtk-tree-model-get-iter-first
  (fix-arguments! '(model::<gtk-tree-model>))
  (fix-body!
        "GtkTreeIter iter; gboolean r;
         r= gtk_tree_model_get_iter_first(model, &iter);
         if (r) SCM_RETURN(SCM_MAKE_GTK_TREE_ITER(&iter));
         else SCM_RETURN(SCM_FALSE);"))

(define-cproc-fix gtk-tree-model-get-value
  (fix-arguments!
   '(tree_model::<gtk-tree-model> iter::<gtk-tree-iter> column::<int>))
  (fix-body!
        "GValue gv; gv.g_type = 0; /* = { 0, }; */
         ScmObj r;
         gtk_tree_model_get_value(tree_model, iter, column, &gv);
#if 0
         Scm_Warn(\"%s:%d\\n\", __FUNCTION__, gv.g_type);
#endif
         r = Scm_UnboxGValue(&gv);
         g_value_unset(&gv);
         SCM_RETURN(r);"))

(define-cproc-fix gtk-tree-model-iter-children
  (fix-arguments! '(model::<gtk-tree-model> parent::<gtk-tree-iter>))
  (fix-body!
        "GtkTreeIter iter; gboolean r;
         r= gtk_tree_model_iter_children(model, &iter, parent);
         if (r) SCM_RETURN(SCM_MAKE_GTK_TREE_ITER(&iter));
         else SCM_RETURN(SCM_FALSE);"))

(define-cproc-fix gtk-tree-model-iter-n-children
  (fix-arguments!
   '(model::<gtk-tree-model> iter::<gtk-tree-iter>-or-null)))

(define-cproc-fix gtk-tree-model-iter-nth-child
  (fix-arguments!
   '(model::<gtk-tree-model> parent::<gtk-tree-iter> n::<int>))
  (fix-body!
        "GtkTreeIter iter; gboolean r;
         r= gtk_tree_model_iter_nth_child(model, &iter, parent, n);
         if (r) SCM_RETURN(SCM_MAKE_GTK_TREE_ITER(&iter));
         else SCM_RETURN(SCM_FALSE);"))

(define-cproc-fix gtk-tree-model-iter-parent
  (fix-arguments! '(model::<gtk-tree-model> child::<gtk-tree-iter>))
  (fix-body!
        "GtkTreeIter iter; gboolean r;
         r= gtk_tree_model_iter_parent(model, &iter, child);
         if (r) SCM_RETURN(SCM_MAKE_GTK_TREE_ITER(&iter));
         else SCM_RETURN(SCM_FALSE);"))

;;==================================================================
;; gtktreeselection
;;

(input-file "gtktreeselection.h")

(define-cproc-fix gtk-tree-selection-get-selected
  (fix-arguments! '(selection::<gtk-tree-selection>))
  (fix-body!
        "GtkTreeIter iter; gboolean r;
  r = gtk_tree_selection_get_selected(selection, NULL, &iter);
  if (r) SCM_RETURN(SCM_MAKE_GTK_TREE_ITER(&iter));
  else   SCM_RETURN(SCM_FALSE);"))

(raw-code
 "static void gtk_tree_selection_foreach_proc(GtkTreeModel *model,
                                              GtkTreePath *path,
                                              GtkTreeIter *iter,
                                              gpointer data)
 {
   Scm_ApplyRec3(SCM_OBJ(data),
                 SCM_MAKE_GTK_TREE_MODEL(model),
                 SCM_MAKE_GTK_TREE_PATH(path),
                 SCM_MAKE_GTK_TREE_ITER(iter));
 }")

(define-cproc-fix gtk-tree-selection-selected-foreach
  (fix-arguments! '(selection::<gtk-tree-selection> proc))
  (fix-body!
        "
  gtk_tree_selection_selected_foreach(selection,
            gtk_tree_selection_foreach_proc, proc);
  SCM_RETURN(SCM_UNDEFINED);"))

;; some procedures are deprecated in Gtk-2.2
(disable-cproc gtk-selection-request)
(disable-cproc gtk-selection-incr-event)
(disable-cproc gtk-selection-notify)
(disable-cproc gtk-selection-property-notify)

;;==================================================================
;; gtktreesortable
;;

(input-file "gtktreesortable.h")

;; disable GtkTreeModelIface
(disable-cclass <gtk-tree-sortable-iface>)

;; GtkTreeSortable is an interface
(define-opaque GtkTreeSortable :gobject)
(define-type <gtk-tree-sortable> "GtkTreeSortable*" #f
  "SCM_GTK_TREE_SORTABLE_P" "SCM_GTK_TREE_SORTABLE" "SCM_MAKE_GTK_TREE_SORTABLE")

;;==================================================================
;; gtktreestore
;;

(input-file "gtktreestore.h")

;; GtkTreeStore implements GtkTreeModel interface
(define-cclass-fix <gtk-tree-store>
  (add-mixin! "Scm_GtkTreeDragSourceClass" "Scm_GtkTreeDragDestClass"
              "Scm_GtkTreeSortableClass" "Scm_GtkTreeModelClass"))

(define-cproc-fix gtk-tree-store-new
  (fix-arguments! '(&rest types))
  (fix-body!
        "int ncolumns = Scm_Length(types);
  GType *gt;
  gt = SCM_NEW_ATOMIC2(GType*, sizeof(GType)*ncolumns);
  Scm_ClassListToGtkTypeList(types, gt);
  SCM_RETURN(SCM_MAKE_GTK_TREE_STORE(gtk_tree_store_newv(ncolumns, gt)));
  "))

(define-cproc-fix gtk-tree-store-set-value
  (fix-arguments! '(store::<gtk-tree-store>
                              iter::<gtk-tree-iter>
                              column::<fixnum>
                              value))
  (fix-body!
        "GValue gval; gval.g_type = 0;
  gtk_tree_store_set_value(store, iter, column,
                           Scm_ObjToGValue(value, &gval));
  g_value_unset(&gval);
  SCM_RETURN(SCM_UNDEFINED);"))

(define-cproc-fix gtk-tree-store-insert
  (fix-arguments! '(store::<gtk-tree-store>
                    parent::<gtk-tree-iter>-or-null
                    position::<int>))
  (fix-body!
        "GtkTreeIter iter;
  gtk_tree_store_insert(store, &iter, parent, position);
  SCM_RETURN(SCM_MAKE_GTK_TREE_ITER(&iter));"))

(define-cproc-fix gtk-tree-store-insert-before
  (fix-arguments! '(store::<gtk-tree-store>
                    parent::<gtk-tree-iter>-or-null
                    sibling::<gtk-tree-iter>-or-null))
  (fix-body!
        "GtkTreeIter iter;
  gtk_tree_store_insert_before(store, &iter, parent, sibling);
  SCM_RETURN(SCM_MAKE_GTK_TREE_ITER(&iter));"))
  
(define-cproc-fix gtk-tree-store-insert-after
  (fix-arguments! '(store::<gtk-tree-store>
                    parent::<gtk-tree-iter>-or-null
                    sibling::<gtk-tree-iter>-or-null))
  (fix-body!
        "GtkTreeIter iter;
  gtk_tree_store_insert_after(store, &iter, parent, sibling);
  SCM_RETURN(SCM_MAKE_GTK_TREE_ITER(&iter));"))

(define-cproc-fix gtk-tree-store-prepend
  (fix-arguments! '(store::<gtk-tree-store>
                    parent::<gtk-tree-iter>-or-null))
  (fix-body!
        "GtkTreeIter iter;
  gtk_tree_store_prepend(store, &iter, parent);
  SCM_RETURN(SCM_MAKE_GTK_TREE_ITER(&iter));"))

(define-cproc-fix gtk-tree-store-append
  (fix-arguments! '(store::<gtk-tree-store>
                    parent::<gtk-tree-iter>-or-null))
  (fix-body!
        "GtkTreeIter iter;
  gtk_tree_store_append(store, &iter, parent);
  SCM_RETURN(SCM_MAKE_GTK_TREE_ITER(&iter));"))

;;==================================================================
;; gtktreeview
;;

(input-file "gtktreeview.h")

;; gtk-tree-view-insert-column-with-attributes - how to handle varargs?

(define-cproc-fix gtk-tree-view-get-columns
  (fix-arguments! '(tree-view::<gtk-tree-view>))
  (fix-body!
        "GList *c = gtk_tree_view_get_columns(tree_view);
         ScmObj r = Scm_GoListToList(c);
         g_list_free(c);
         SCM_RETURN(r);"))

(define-cproc-fix gtk-tree-view-set-cursor
  (fix-arguments!
        '(view::<gtk-tree-view> path::<gtk-tree-path>
          focus-column::<gtk-tree-view-column>-or-null
          start-editiong::<boolean>))
  )

(define-cproc-fix gtk-tree-view-get-cursor
  (fix-arguments! '(tree_view::<gtk-tree-view>))
  (fix-body! "GtkTreePath *path; GtkTreeViewColumn *col;
  ScmObj spath, scol;
  gtk_tree_view_get_cursor(tree_view, &path, &col);
  spath = path ? SCM_MAKE_GTK_TREE_PATH(path): SCM_FALSE;
  scol  = col? SCM_MAKE_GTK_TREE_VIEW_COLUMN(col) : SCM_FALSE;
  SCM_RETURN2(spath, scol);
  "))

(define-cproc-fix gtk-tree-view-get-path-at-pos
  (fix-arguments! '(tree_view::<gtk-tree-view>
                    x::<int> y::<int>))
  (fix-body! "GtkTreePath *path; GtkTreeViewColumn *col; gint cx, cy;
  gboolean r = gtk_tree_view_get_path_at_pos(tree_view, x, y,
                                             &path, &col, &cx, &cy);
  if (r) {
    SCM_RETURN4(SCM_MAKE_GTK_TREE_PATH(path), 
                SCM_MAKE_GTK_TREE_VIEW_COLUMN(col),
                Scm_MakeInteger(x), Scm_MakeInteger(y));
  } else {
    SCM_RETURN4(SCM_FALSE, SCM_FALSE, SCM_FALSE, SCM_FALSE);
  }"))

(define-cproc-fix gtk-tree-view-widget-to-tree-coords
  (fix-arguments! '(tree_view::<gtk-tree-view>
                    wx::<int> wy::<int>))
  (fix-body! "gint tx, ty;
  gtk_tree_view_widget_to_tree_coords(tree_view, wx, wy, &tx, &ty);
  SCM_RETURN2(Scm_MakeInteger(tx), Scm_MakeInteger(ty));"))

(define-cproc-fix gtk-tree-view-tree-to-widget-coords
  (fix-arguments! '(tree_view::<gtk-tree-view>
                    tx::<int> ty::<int>))
  (fix-body! "gint wx, wy;
  gtk_tree_view_tree_to_widget_coords(tree_view, tx, ty, &wx, &wy);
  SCM_RETURN2(Scm_MakeInteger(wx), Scm_MakeInteger(wy));"))


;;==================================================================
;; gtktreeviewcolumn
;;

(input-file "gtktreeviewcolumn.h")

(define-cproc-fix gtk-tree-view-column-get-cell-renderers
  (fix-body! "GList *lis = gtk_tree_view_column_get_cell_renderers(tree_column);
  ScmObj r = Scm_GoListToList(lis);
  g_list_free(lis);
  SCM_RETURN(r);"))

(define-cproc-fix gtk-tree-view-column-cell-get-position
  (fix-arguments! '(tree_column::<gtk-tree-view-column>
                    cell_renderer::<gtk-cell-renderer>))
  (fix-body! "gint start_pos, width; gboolean r;
  r = gtk_tree_view_column_cell_get_position(tree_column, cell_renderer,
                                             &start_pos, &width);
  if (r) {
    SCM_RETURN2(Scm_MakeInteger(start_pos), Scm_MakeInteger(width));
  } else {
    SCM_RETURN2(SCM_FALSE, SCM_FALSE);
  }"))


(define-cproc gtk-cell-set-color (cell_renderer::<gtk-cell-renderer> property::<const-gchar*> color::<gdk-color>)
  "g_object_set(cell_renderer, property, color, 0);
SCM_RETURN(SCM_UNDEFINED);")

;; mmc:

;; gtk_tree_view_column_set_cell_data_func
(define-cproc-fix gtk-tree-view-column-set-cell-data-func
  (fix-arguments!  '(tree_column::<gtk-tree-view-column>
                     cell_renderer::<gtk-cell-renderer>
                     handler::<procedure>
                     ;; function
                     ))
  (fix-body! "
GClosure *closure = Scm_MakeGClosure(handler);
 gtk_tree_view_column_set_cell_data_func(
   tree_column, cell_renderer,
   universal_cell_function, closure, NULL);
  SCM_RETURN(SCM_UNDEFINED);"))




;; (define-cproc gtk-tree-view-column-set-cell-data-func (tree_column::<gtk-tree-view-column> cell_renderer::<gtk-cell-renderer> func::(UNKNOWN . GtkTreeCellDataFunc) func_data::(UNKNOWN . gpointer) destroy::(UNKNOWN . GtkDestroyNotify)) (return <void> gtk_tree_view_column_set_cell_data_func))

(input-file "gtkcellrendererpixbuf.h")

(define-cproc gtk-pixbuf-render-set-lazy-loader  (cell_renderer::<gtk-cell-renderer-pixbuf>
                                                  ;; fixme:
                                                  handler::<procedure>) ;<function>
  "
GClosure *closure = Scm_MakeGClosure(handler);
/*gtk_cell_renderer_pixbuf_set_property*/

GValue gv1 = {0,};
g_value_init(&gv1,G_TYPE_OBJECT);
g_value_set_object(&gv1, NULL);
g_object_set_property((GObject*)cell_renderer, \"pixbuf\", &gv1);


GValue gv = {0,};
g_value_init(&gv,G_TYPE_POINTER);

#if 0
Scm_Warn(\"%s start\\n\",__FUNCTION__);
#endif

g_value_set_pointer(&gv, (gpointer) closure);

g_object_set_property((GObject*)cell_renderer, \"lazy-load\", &gv);

#if 0
Scm_Warn(\"%s end\\n\",__FUNCTION__);
#endif


SCM_RETURN(SCM_UNDEFINED);")




;;==================================================================
;; gtktypeutils
;;

(input-file "gtktypeutils.h")

;; GtkArg - avoid union fields
(define-cclass-fix <gtk-arg>
  (ignore-field-except! '(type name)))

;;==================================================================
;; gtkwidget.h
;;

(input-file "gtkwidget.h")

;; these defined as macro in C
(define-cproc gtk-widget-flags (widget::<gtk-widget>)
  (call <ulong> "GTK_WIDGET_FLAGS"))
(define-cproc gtk-widget-toplevel? (widget::<gtk-widget>)
  (call <boolean> "GTK_WIDGET_TOPLEVEL"))
(define-cproc gtk-widget-no-window? (widget::<gtk-widget>)
  (call <boolean> "GTK_WIDGET_NO_WINDOW"))
(define-cproc gtk-widget-realized? (widget::<gtk-widget>)
  (call <boolean> "GTK_WIDGET_REALIZED"))
(define-cproc gtk-widget-mapped? (widget::<gtk-widget>)
  (call <boolean> "GTK_WIDGET_MAPPED"))
(define-cproc gtk-widget-visible? (widget::<gtk-widget>)
  (call <boolean> "GTK_WIDGET_VISIBLE"))
(define-cproc gtk-widget-drawable? (widget::<gtk-widget>)
  (call <boolean> "GTK_WIDGET_DRAWABLE"))
(define-cproc gtk-widget-sensitive? (widget::<gtk-widget>)
  (call <boolean> "GTK_WIDGET_SENSITIVE"))
(define-cproc gtk-widget-parent-sensitive? (widget::<gtk-widget>)
  (call <boolean> "GTK_WIDGET_PARENT_SENSITIVE"))
(define-cproc gtk-widget-is-sensitive? (widget::<gtk-widget>)
  (call <boolean> "GTK_WIDGET_IS_SENSITIVE"))
(define-cproc gtk-widget-can-focus? (widget::<gtk-widget>)
  (call <boolean> "GTK_WIDGET_CAN_FOCUS"))
(define-cproc gtk-widget-has-focus? (widget::<gtk-widget>)
  (call <boolean> "GTK_WIDGET_HAS_FOCUS"))
(define-cproc gtk-widget-can-default? (widget::<gtk-widget>)
  (call <boolean> "GTK_WIDGET_CAN_DEFAULT"))
(define-cproc gtk-widget-has-default? (widget::<gtk-widget>)
  (call <boolean> "GTK_WIDGET_HAS_DEFAULT"))
(define-cproc gtk-widget-has-grab? (widget::<gtk-widget>)
  (call <boolean> "GTK_WIDGET_HAS_GRAB"))
(define-cproc gtk-widget-rc-style? (widget::<gtk-widget>)
  (call <boolean> "GTK_WIDGET_RC_STYLE"))
(define-cproc gtk-widget-composite-child? (widget::<gtk-widget>)
  (call <boolean> "GTK_WIDGET_COMPOSITE_CHILD"))
(define-cproc gtk-widget-app-paintable? (widget::<gtk-widget>)
  (call <boolean> "GTK_WIDGET_APP_PAINTABLE"))
(define-cproc gtk-widget-receives-default? (widget::<gtk-widget>)
  (call <boolean> "GTK_WIDGET_RECEIVES_DEFAULT"))
(define-cproc gtk-widget-double-buffered? (widget::<gtk-widget>)
  (call <boolean> "GTK_WIDGET_DOUBLE_BUFFERED"))

(define-cproc gtk-widget-set-flags (widget::<gtk-widget> flag::<ulong>)
  (call <void> "GTK_WIDGET_SET_FLAGS"))
(define-cproc gtk-widget-unset-flags (widget::<gtk-widget> flag::<ulong>)
  (call <void> "GTK_WIDGET_UNSET_FLAGS"))

(define-cproc-fix gtk-widget-list-accel-closures
  (fix-body! "GList *lis = gtk_widget_list_accel_closures(widget);
  ScmObj r = Scm_GoListToList(lis);
  g_list_free(lis);
  SCM_RETURN(r);"))

;; Returns two values
(define-cproc-fix gtk-widget-get-pointer
  (fix-arguments! '(widget::<gtk-widget>))
  (fix-body!
   "gint x, y; gtk_widget_get_pointer(widget, &x, &y);
  SCM_RETURN2(Scm_MakeInteger(x), Scm_MakeInteger(y));"))

(define-cproc-fix gtk-widget-get-size-request
  (fix-arguments! '(widget::<gtk-widget>))
  (fix-body!
   "gint w, h; gtk_widget_get_size_request(widget, &w, &h);
  SCM_RETURN2(Scm_MakeInteger(w), Scm_MakeInteger(h));"))

(define-cproc-fix gtk-widget-translate-coordinates
  (fix-arguments!
   '(src-widget::<gtk-widget> dst-widget::<gtk-widget>
                              src-x::<int> src-y::<int>))
  (fix-body!
        "gint dst_x, dst_y;
  gtk_widget_translate_coordinates(src_widget, dst_widget,
                                   src_x, src_y, &dst_x, &dst_y);
  SCM_RETURN2(Scm_MakeInteger(dst_x), Scm_MakeInteger(dst_y));"))

(define-cproc-fix gtk-widget-style-get-property
  (fix-arguments!
   '(widget::<gtk-widget> property-name::<const-gchar*>))
  (fix-body!
   "GValue gv;  ScmObj r;
  gv.g_type = 0;
  gtk_widget_style_get_property(widget, property_name, &gv);
  r = Scm_UnboxGValue(&gv);
  g_value_unset(&gv);
  SCM_RETURN(r);"))

(define-cproc-fix gtk-widget-path
  (fix-arguments! '(widget::<gtk-widget>))
  (fix-body! "guint size; gchar *path; ScmObj p;
  gtk_widget_path(widget, &size, &path, NULL);
  /* Gtk manual is not clear who owns path */
  p = Scm_MakeString((const char *)path, size, -1, SCM_MAKSTR_COPYING);
  SCM_RETURN(p);"))

(define-cproc-fix gtk-widget-class-path
  (fix-arguments! '(widget::<gtk-widget>))
  (fix-body! "guint size; gchar *path; ScmObj p;
  gtk_widget_class_path(widget, &size, &path, NULL);
  /* Gtk manual is not clear who owns path */
  p = Scm_MakeString((const char *)path, size, -1, SCM_MAKSTR_COPYING);
  SCM_RETURN(p);"))

(disable-cproc gtk-widget-destroyed)
(disable-cproc gtk-widget-style-get-valist)


;;; mmc:
(define-cproc-fix gtk-widget-get-child-requisition
  (fix-arguments! '(widget::<gtk-widget>))
  (fix-body!
   "
GtkRequisition a;
gtk_widget_get_child_requisition(widget, &a);
SCM_RETURN (Scm_Values2(Scm_MakeInteger(a.width), Scm_MakeInteger(a.height)));
"))


;;; mmc:
;; (call <const-gchar*>-or-null
;; gtk_widget_get_composite_name
(define-cproc-fix gtk-widget-get-composite-name
  ;(fix-arguments! '(widget::<gtk-widget>))
  ;(widget::<gtk-widget>)
  ;; (call <gchar*> "")
  (fix-body! "gchar* result= gtk_widget_get_composite_name(widget);
if (result){
   SCM_RETURN(SCM_MAKE_STR_COPYING((const char *)result));
}else Scm_Error(\"gtk-widget-get-composite-name: not composite\");"))


;;(input-file "gtkrc.h")      ;; is this necessary ?
(define-type <list-of-gchar*> "gchar **" "list of C strings, free-d by the external library"
  "SCM_STRING_LIST_P"
  "SCM_STRING_LIST" "SCM_MAKE_STRING_LIST")

;; the argument should be of a more specialized type b/c the external library makes a
;; further copy of the strings. So, the C strings extracted, can be freed (if allocated).
(define-cproc-fix gtk-rc-set-default-files
  (fix-arguments! '(strings::<list-of-gchar*>))
  (fix-body! "
gtk_rc_set_default_files(strings);
/* The C strings are g_strdup-ed, so could be freed immediately.
 * But they are allocated atomically from (Boehm) GC
  */
SCM_RETURN(SCM_UNDEFINED);"))

(define-cproc-fix gtk-rc-get-default-files
  (fix-body! "SCM_RETURN(SCM_MAKE_STRING_LIST(gtk_rc_get_default_files()));"))
  ;(set! (return-type-of self) '<list-of-gchar*>))       ;;  what's wrong with this?



;;==================================================================
;; gtkcelllayout
;;
;; mmc: as a model i use the  
(input-file "gtkcelllayout.h")

;; disable *Iface
(disable-cclass <gtk-cell-layout-iface>)
(disable-cclass <gtk-cell-layout>)

;(define-opaque GtkCellLayoutIface :gobject)
(define-opaque GtkCellLayout :gobject)
; (define-opaque GtkTreeDragDest :gobject)

;;`generic':
"#define SCM_GTK_IFACE_P(obj,iface_class, iface_p)    (SCM_GOBJECT_P(obj) && iface_p(SCM_GOBJECT_UNBOX(iface_class, obj)))"

"#define SCM_GTK_CELL_LAYOUT_P(obj)    SCM_GTK_IFACE_P(obj, GtkCellLayout, SCM_CLASS_GTK_CELL_LAYOUT)"

(define-type <gtk-cell-layout> "GtkCellLaout*" #f
  "SCM_GTK_CELL_LAYOUT_P" "SCM_GTK_CELL_LAYOUT" "SCM_MAKE_GTK_CELL_LAYOUT")


;; g_type_is_a()
;gtk_cell_layout_get_type()

;GTK_IS_CELL_LAYOUT(obj)



;;==================================================================
;; gtkdnd.h  [mmc!]
;;

(input-file "gtkdnd.h")

(define-cproc-fix gtk-drag-dest-set
  (fix-arguments! '(widget::<gtk-widget> flags::<int> targets actions::<int>))
  (fix-body!
   "
   if (! SCM_LISTP(targets))
      Scm_Error(\"LIST of gtk-target-entry/s required, but got %S\", targets);
   int   n_targets = 0; /* Scm_Length(targets); */

   ScmObj p;
/* First*/
   SCM_FOR_EACH(p, targets) {
      if (!SCM_GTK_TARGET_ENTRY_P(SCM_CAR(p))) Scm_Error(\"gtk-target-entry required, but got %S\", SCM_CAR(p));
      n_targets++;
   }

   GtkTargetEntry* c_targets = malloc((n_targets) * sizeof (GtkTargetEntry)); /* + 1*/
   int i = 0;
   SCM_FOR_EACH(p, targets) {
      memcpy (c_targets + i++, SCM_GTK_TARGET_ENTRY(SCM_CAR(p)), sizeof (GtkTargetEntry));
   };
/* Get the `n_targets' */

   gtk_drag_dest_set(widget, flags, c_targets, n_targets, actions);
   free(c_targets);
   return SCM_UNDEFINED;"))


;; Same!
(define-cproc-fix gtk-drag-source-set
  (fix-arguments! '(widget::<gtk-widget> flags::<int> targets actions::<int>))
  (fix-body!
   "
   if (! SCM_LISTP(targets))
      Scm_Error(\"LIST of gtk-target-entry/s required, but got %S\", targets);
   int   n_targets = 0; /* Scm_Length(targets); */

   ScmObj p;
/* First*/
   SCM_FOR_EACH(p, targets) {
      if (!SCM_GTK_TARGET_ENTRY_P(SCM_CAR(p)))
          Scm_Error(\"gtk-target-entry required, but got %S\", SCM_CAR(p));
      n_targets++;
   }

   GtkTargetEntry* c_targets = malloc((n_targets) * sizeof (GtkTargetEntry)); /* + 1*/
   int i = 0;
   SCM_FOR_EACH(p, targets) {
      memcpy (c_targets + i++, SCM_GTK_TARGET_ENTRY(SCM_CAR(p)), sizeof (GtkTargetEntry));
      Scm_Warn(\"%d -> %s\", i, SCM_GTK_TARGET_ENTRY(SCM_CAR(p))->target);
   };
/* Get the `n_targets' */

   Scm_Warn(\"gtk-drag-source-set: %d\", n_targets);
   gtk_drag_source_set(widget, flags, c_targets, n_targets, actions);
   free(c_targets);
   return SCM_UNDEFINED;"))



;;==================================================================
;; gtkwindow.h
;;

(input-file "gtkwindow.h")

(define-cproc-fix gtk-window-get-frame-dimensions
  (fix-arguments! '(window::<gtk-window>))
  (fix-body! "gint l, t, r, b;
  gtk_window_get_frame_dimensions(window, &l, &t, &r, &b);
  SCM_RETURN4(Scm_MakeInteger(l), Scm_MakeInteger(t), Scm_MakeInteger(r), Scm_MakeInteger(b));"))

(define-cproc-fix gtk-window-get-icon-list
  (fix-body! "GList *lis = gtk_window_get_icon_list(window);
  ScmObj r = Scm_GoListToList(lis);
  g_list_free(lis);
  SCM_RETURN(r);"))

(define-cproc-fix gtk-window-set-icon-list
  (fix-arguments! '(window::<gtk-window> lis))
  (fix-body! "GList *l = Scm_ListToGList(lis);
  gtk_window_set_icon_list(window, l);
  SCM_RETURN(SCM_UNDEFINED);"))

(define-cproc-fix gtk-window-set-icon-from-file
  (fix-arguments! '(window::<gtk-window>
                    filename::<const-gchar*>))
  (fix-body! "GError *err = NULL; gboolean r;
  r = gtk_window_set_icon_from_file(window, filename, &err);
  if (!r) {
    Scm_Error(\"gtk-window-set-icon-from-file: %s\", err->message);
  }
  SCM_RETURN(SCM_TRUE);"))

(define-cproc-fix gtk-window-get-default-icon-list
  (fix-body! "GList *lis = gtk_window_get_default_icon_list();
  ScmObj r = Scm_GoListToList(lis);
  g_list_free(lis);
  SCM_RETURN(r);"))

(define-cproc-fix gtk-window-set-default-icon-list
  (fix-arguments! '(lis))
  (fix-body! "GList *l = Scm_ListToGList(lis);
  gtk_window_set_default_icon_list(l);
  SCM_RETURN(SCM_UNDEFINED);"))

(define-cproc-fix gtk-window-set-default-icon-from-file
  (fix-arguments! '(filename::<const-gchar*>))
  (fix-body! "GError *err = NULL; gboolean r;
  r = gtk_window_set_default_icon_from_file(filename, &err);
  if (!r) {
    Scm_Error(\"gtk-window-set-default-icon-from-file: %s\", err->message);
  }
  SCM_RETURN(SCM_TRUE);"))

(define-cproc-fix gtk-window-list-toplevels
  (fix-body! "GList *lis = gtk_window_list_toplevels();
  ScmObj r = Scm_GoListToList(lis);
  /* Gtk manual is not clear about whether we should free lis or not. */
  SCM_RETURN(r);"))

(define-cproc-fix gtk-window-get-size
  (fix-arguments! '(widget::<gtk-window>))
  (fix-body!
   "gint w, h; gtk_window_get_size(widget, &w, &h);
  SCM_RETURN2(Scm_MakeInteger(w), Scm_MakeInteger(h));"))

(define-cproc-fix gtk-window-get-default-size
  (fix-arguments! '(widget::<gtk-window>))
  (fix-body!
   "gint w, h; gtk_window_get_size(widget, &w, &h);
  SCM_RETURN2(Scm_MakeInteger(w), Scm_MakeInteger(h));"))

(define-cproc-fix gtk-window-get-position
  (fix-arguments! '(widget::<gtk-window>))
  (fix-body!
   "gint x, y; gtk_window_get_position(widget, &x, &y);
  SCM_RETURN2(Scm_MakeInteger(x), Scm_MakeInteger(y));"))


;;; [10 gen 05]
;(define-cclass <gerror>
(input-file "gtkuimanager.h")

(define-cproc-fix gtk-ui-manager-add-ui-from-file
  (fix-arguments! '(self::<gtk-ui-manager> filename::<const-gchar*>))
  (fix-body! "GError* err = NULL; uint r;
  r = gtk_ui_manager_add_ui_from_file(self, filename, &err);
  if (!r) {
    Scm_Error(\"gtk-ui-manager-add-ui-from-file: %s\", err->message);
  }
  SCM_RETURN(SCM_TRUE);"))


;;==================================================================
;; gtkfilechooser
;;

(input-file "gtkfilechooser.h")

(define-opaque GtkFileChooser :gobject)


;; gtkfilechooserbutton
(input-file "gtkfilechooserbutton.h")

(define-cclass-fix <gtk-file-chooser-button>
  (add-mixin! "Scm_GtkFileChooserClass"))


(input-file "gtkfilechooserwidget.h")
(define-cclass-fix <gtk-file-chooser-widget>
  (add-mixin! "Scm_GtkFileChooserClass"))


(input-file "gtkfilechooserdialog.h")
(define-cclass-fix <gtk-file-chooser-dialog>
  (add-mixin! "Scm_GtkFileChooserClass"))

(define-cproc-fix gtk-file-chooser-dialog-new
  ;(call <gtk-widget> gtk_file_chooser_dialog_new)
  ;; Needs NULL!
  (fix-arguments!
   '(title::<const-gchar*> parent::<gtk-window> action::<int>
                           first_button_text::<const-gchar*> response_id::<int>
                           ;&rest text-responses ;;...
                           ))
  ;; fixme: I should accept the var-arg list!
  (fix-body! "
return Scm_MakeGObject(G_OBJECT(gtk_file_chooser_dialog_new(title, parent, action, first_button_text, response_id, NULL)));")
  )

; gtk-file-chooser-dialog-new-with-backend


;; Local variables:
;; mode: scheme
;; end:
